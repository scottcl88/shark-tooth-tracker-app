//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase, HttpContext } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export class ClientBase {
  /**
   * authorization token value
   */
  public token: string | null;

  // constructor(private authService: AuthService) {
  //   this.token = '';
  // } // @ts-ignore
  protected transformResult(url: string, response: any, processor: (response: any) => Observable<any>) {
    // console.log("transformResult added: ", url, response, processor);

    //Have to loop through each object to add the "Z" so that I can treat the incoming DateTime as UTC instead of local by default
    if (response?.data != null) {
      if (Array.isArray(response.data)) {
        response.data.forEach((item: any) => {
          Object.entries(item).forEach(([key, value]: any) => {
            //   console.log(value);
            var regex = new RegExp(/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|)/g);
            if (regex.test(value)) {
              item[key] = value + 'Z';
            }
          });
        });
      } else {
        Object.entries(response?.data).forEach(([key, value]: any) => {
          //   console.log(value);
          var regex = new RegExp(/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|)/g);
          if (regex.test(value)) {
            response.data[key] = value + 'Z';
          }
        });
      }
    }

    // console.log("transformResult new: ", url, response, processor);
    if (response.status == 401) {
      // console.log('Response 401');
      // window.location.href = '/login';
    }

    return processor(response);
  }

  async getToken(): Promise<any> {
    // return new Promise((resolve, reject) => {
    //   this.authService.getAccessTokenSilently().subscribe(res => {
    //     resolve(res);
    //   }, err => {
    //     reject(err);
    //   });
    // })
  }
  protected async transformOptions(options: any) {
    options.headers['Access-Control-Allow-Origin'] = '*';
    options.headers['Access-Control-Allow-Headers'] = 'X-Requested-With, Content-Type, Accept, Origin, Authorization';
    options.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, PATCH, OPTIONS';
    options.headers['Accept'] = '*/*';
    // options.withCredentials = true;

    // var token = await this.getToken();
    // options.headers.Authorization = "Bearer " + token;

    return Promise.resolve(options);
  }
  // @ts-ignore
  protected transformResponse(data: any): Observable<any> {
    let resp;
    try {
      resp = JSON.parse(data);
    } catch (error) {
      throw Error(`[requestClient] Error parsingJSON data - ${JSON.stringify(error)}`);
    }
    if (resp.status === 'success') {
      return resp.data;
    } else {
      throw Error(`Request failed with reason -  ${data}`);
    }
  }
}

@Injectable()
export class CityClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get a list of cities from a state
     * @param state (optional) 
     * @return Success
     */
    getcities(state: string | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/city/getcities?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetcities(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetcities(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetcities(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get a list of cities from a state
     * @param state (optional) 
     * @param searchText (optional) 
     * @return Success
     */
    autocomplete(state: string | undefined, searchText: string | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/city/autocomplete?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processAutocomplete(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processAutocomplete(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAutocomplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DocumentsClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    download(licensePlateId: number, documentId: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/download/{licensePlateId}/{documentId}";
        if (licensePlateId === undefined || licensePlateId === null)
            throw new Error("The parameter 'licensePlateId' must be defined.");
        url_ = url_.replace("{licensePlateId}", encodeURIComponent("" + licensePlateId));
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processDownload(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDownload(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDownload(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    view(licensePlateId: number, documentId: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/documents/view/{licensePlateId}/{documentId}";
        if (licensePlateId === undefined || licensePlateId === null)
            throw new Error("The parameter 'licensePlateId' must be defined.");
        url_ = url_.replace("{licensePlateId}", encodeURIComponent("" + licensePlateId));
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processView(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processView(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processView(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param licensePlateId (optional) 
     * @param file (optional) 
     * @return Success
     */
    addLicensePlateImage(licensePlateId: number | undefined, file: FileParameter | undefined, httpContext?: HttpContext): Observable<UploadResult> {
        let url_ = this.baseUrl + "/api/documents/add-license-plate-image?";
        if (licensePlateId === null)
            throw new Error("The parameter 'licensePlateId' cannot be null.");
        else if (licensePlateId !== undefined)
            url_ += "licensePlateId=" + encodeURIComponent("" + licensePlateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processAddLicensePlateImage(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processAddLicensePlateImage(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UploadResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UploadResult>;
        }));
    }

    protected processAddLicensePlateImage(response: HttpResponseBase): Observable<UploadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UploadResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UploadClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param files (optional) 
     * @return Success
     */
    multiple(licensePlateId: number, files: FileParameter[] | undefined, httpContext?: HttpContext): Observable<UploadResult[]> {
        let url_ = this.baseUrl + "/api/documents/upload/multiple/{licensePlateId}";
        if (licensePlateId === undefined || licensePlateId === null)
            throw new Error("The parameter 'licensePlateId' must be defined.");
        url_ = url_.replace("{licensePlateId}", encodeURIComponent("" + licensePlateId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files === null || files === undefined)
            throw new Error("The parameter 'files' cannot be null.");
        else
            files.forEach(item_ => content_.append("files", item_.data, item_.fileName ? item_.fileName : "files") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processMultiple(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processMultiple(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UploadResult[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UploadResult[]>;
        }));
    }

    protected processMultiple(response: HttpResponseBase): Observable<UploadResult[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UploadResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FeedbackClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Add feedback to the database
     * @param body (optional) 
     * @return Success
     */
    submitFeedback(body: FeedbackModel | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/feedback/SubmitFeedback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processSubmitFeedback(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processSubmitFeedback(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitFeedback(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GameClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Sends an email with game data as json attachment
     * @param body (optional) 
     * @return Success
     */
    emailGameData(body: EmailGameDataRequest | undefined, httpContext?: HttpContext): Observable<boolean> {
        let url_ = this.baseUrl + "/api/game/email-game-data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processEmailGameData(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processEmailGameData(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processEmailGameData(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get all games
     * @return Success
     */
    getAll(httpContext?: HttpContext): Observable<GameModel[]> {
        let url_ = this.baseUrl + "/api/game/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameModel[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GameModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GameModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get all finished games
     * @return Success
     */
    getAllFinished(httpContext?: HttpContext): Observable<GameModel[]> {
        let url_ = this.baseUrl + "/api/game/get-all-finished";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllFinished(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllFinished(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameModel[]>;
        }));
    }

    protected processGetAllFinished(response: HttpResponseBase): Observable<GameModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GameModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get current game
     * @return Success
     */
    getCurrent(httpContext?: HttpContext): Observable<GameModel> {
        let url_ = this.baseUrl + "/api/game/get-current";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetCurrent(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetCurrent(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameModel>;
        }));
    }

    protected processGetCurrent(response: HttpResponseBase): Observable<GameModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Add license to game
     * @param body (optional) 
     * @return Success
     */
    add(body: LicenseGameRequest | undefined, httpContext?: HttpContext): Observable<GameModel> {
        let url_ = this.baseUrl + "/api/game/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processAdd(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processAdd(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameModel>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<GameModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Remove license to game
     * @param body (optional) 
     * @return Success
     */
    remove(body: LicenseGameRequest | undefined, httpContext?: HttpContext): Observable<GameModel> {
        let url_ = this.baseUrl + "/api/game/remove";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processRemove(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processRemove(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameModel>;
        }));
    }

    protected processRemove(response: HttpResponseBase): Observable<GameModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create game
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateGameRequest | undefined, httpContext?: HttpContext): Observable<GameModel> {
        let url_ = this.baseUrl + "/api/game/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processCreate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processCreate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameModel>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<GameModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update game
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateGameRequest | undefined, httpContext?: HttpContext): Observable<GameModel> {
        let url_ = this.baseUrl + "/api/game/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<GameModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete game by id
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined, httpContext?: HttpContext): Observable<boolean> {
        let url_ = this.baseUrl + "/api/game/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDelete(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Restart game by id
     * @param id (optional) 
     * @return Success
     */
    restart(id: number | undefined, httpContext?: HttpContext): Observable<boolean> {
        let url_ = this.baseUrl + "/api/game/restart?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processRestart(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processRestart(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processRestart(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ApiClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get game by id
     * @return Success
     */
    game(id: number, httpContext?: HttpContext): Observable<GameModel> {
        let url_ = this.baseUrl + "/api/game/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGame(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGame(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GameModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GameModel>;
        }));
    }

    protected processGame(response: HttpResponseBase): Observable<GameModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GameModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get licensePlate by id
     * @return Success
     */
    licensePlatesGet(id: number, httpContext?: HttpContext): Observable<LicensePlateModel> {
        let url_ = this.baseUrl + "/api/licensePlates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processLicensePlatesGet(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processLicensePlatesGet(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LicensePlateModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LicensePlateModel>;
        }));
    }

    protected processLicensePlatesGet(response: HttpResponseBase): Observable<LicensePlateModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LicensePlateModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete licensePlate by id
     * @return Success
     */
    licensePlatesDelete(id: number, httpContext?: HttpContext): Observable<boolean> {
        let url_ = this.baseUrl + "/api/licensePlates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processLicensePlatesDelete(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processLicensePlatesDelete(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processLicensePlatesDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LicensePlatesClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Search for licensePlates
     * @return Success
     */
    search(query: string, httpContext?: HttpContext): Observable<LicensePlateModel[]> {
        let url_ = this.baseUrl + "/api/licensePlates/search/{query}";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined.");
        url_ = url_.replace("{query}", encodeURIComponent("" + query));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processSearch(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processSearch(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LicensePlateModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LicensePlateModel[]>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<LicensePlateModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LicensePlateModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    view(licensePlateId: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/licensePlates/view/{licensePlateId}";
        if (licensePlateId === undefined || licensePlateId === null)
            throw new Error("The parameter 'licensePlateId' must be defined.");
        url_ = url_.replace("{licensePlateId}", encodeURIComponent("" + licensePlateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processView(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processView(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processView(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get all licensePlates
     * @return Success
     */
    getAll(httpContext?: HttpContext): Observable<LicensePlateModel[]> {
        let url_ = this.baseUrl + "/api/licensePlates/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LicensePlateModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LicensePlateModel[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LicensePlateModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LicensePlateModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get all states
     * @return Success
     */
    getAllStates(httpContext?: HttpContext): Observable<StateModel[]> {
        let url_ = this.baseUrl + "/api/licensePlates/get-all-states";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAllStates(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAllStates(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StateModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StateModel[]>;
        }));
    }

    protected processGetAllStates(response: HttpResponseBase): Observable<StateModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StateModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create licensePlate
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateLicensePlateRequest | undefined, httpContext?: HttpContext): Observable<LicensePlateModel> {
        let url_ = this.baseUrl + "/api/licensePlates/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processCreate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processCreate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LicensePlateModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LicensePlateModel>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LicensePlateModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LicensePlateModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update licensePlate
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateLicensePlateRequest | undefined, httpContext?: HttpContext): Observable<LicensePlateModel> {
        let url_ = this.baseUrl + "/api/licensePlates/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LicensePlateModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LicensePlateModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LicensePlateModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LicensePlateModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SeedingClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Seed database
     * @return Success
     */
    seed(httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/seeding/seed";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processSeed(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processSeed(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSeed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StatefactsClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get a random state fact
     * @return Success
     */
    random(httpContext?: HttpContext): Observable<StateFactModel> {
        let url_ = this.baseUrl + "/api/statefacts/random";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processRandom(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processRandom(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StateFactModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StateFactModel>;
        }));
    }

    protected processRandom(response: HttpResponseBase): Observable<StateFactModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StateFactModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get a random state fact
     * @return Success
     */
    state(stateId: number, httpContext?: HttpContext): Observable<StateFactResult> {
        let url_ = this.baseUrl + "/api/statefacts/state/{stateId}";
        if (stateId === undefined || stateId === null)
            throw new Error("The parameter 'stateId' must be defined.");
        url_ = url_.replace("{stateId}", encodeURIComponent("" + stateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processState(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processState(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StateFactResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StateFactResult>;
        }));
    }

    protected processState(response: HttpResponseBase): Observable<StateFactResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StateFactResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserClient extends ClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Search for users by email or name
     * @return Success
     */
    search(query: string, httpContext?: HttpContext): Observable<UserModel[]> {
        let url_ = this.baseUrl + "/api/user/search/{query}";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined.");
        url_ = url_.replace("{query}", encodeURIComponent("" + query));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processSearch(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processSearch(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel[]>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<UserModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get the currently signed in user
     * @return Success
     */
    getUser(httpContext?: HttpContext): Observable<UserModel> {
        let url_ = this.baseUrl + "/api/user/get-user";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetUser(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetUser(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel>;
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<UserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get all non-deleted users
     * @return Success
     */
    getAll(httpContext?: HttpContext): Observable<UserModel[]> {
        let url_ = this.baseUrl + "/api/user/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGetAll(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get the user by guid
     * @return Success
     */
    guid(userGUID: string, httpContext?: HttpContext): Observable<UserModel> {
        let url_ = this.baseUrl + "/api/user/guid?";
        if (userGUID === undefined || userGUID === null)
            throw new Error("The parameter 'userGUID' must be defined and cannot be null.");
        else
            url_ += "userGUID=" + encodeURIComponent("" + userGUID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGuid(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGuid(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel>;
        }));
    }

    protected processGuid(response: HttpResponseBase): Observable<UserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateRequest | undefined, httpContext?: HttpContext): Observable<AuthenticateResponse> {
        let url_ = this.baseUrl + "/api/user/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processAuthenticate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processAuthenticate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResponse>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticateByDevice(body: AuthenticateByDeviceRequest | undefined, httpContext?: HttpContext): Observable<AuthenticateResponse> {
        let url_ = this.baseUrl + "/api/user/authenticate-by-device";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processAuthenticateByDevice(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processAuthenticateByDevice(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResponse>;
        }));
    }

    protected processAuthenticateByDevice(response: HttpResponseBase): Observable<AuthenticateResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param deviceId (optional) 
     * @return Success
     */
    generateSecret(deviceId: string | undefined, httpContext?: HttpContext): Observable<SecretResponse> {
        let url_ = this.baseUrl + "/api/user/generate-secret?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processGenerateSecret(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processGenerateSecret(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecretResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecretResponse>;
        }));
    }

    protected processGenerateSecret(response: HttpResponseBase): Observable<SecretResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecretResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    refreshToken(body: RefreshTokenRequest | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/user/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processRefreshToken(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processRefreshToken(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    revokeToken(body: RevokeTokenRequest | undefined, httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/revoke-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processRevokeToken(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processRevokeToken(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processRevokeToken(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    refreshTokens(id: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/user/refresh-tokens/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processRefreshTokens(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processRefreshTokens(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRefreshTokens(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterRequest | undefined, httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processRegister(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processRegister(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyEmail(body: VerifyEmailRequest | undefined, httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/verify-email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processVerifyEmail(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processVerifyEmail(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processVerifyEmail(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    requestEditAccess(httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/request-edit-access";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processRequestEditAccess(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processRequestEditAccess(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processRequestEditAccess(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forgotPassword(body: ForgotPasswordRequest | undefined, httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processForgotPassword(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processForgotPassword(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateResetToken(body: ValidateResetTokenRequest | undefined, httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/validate-reset-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processValidateResetToken(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processValidateResetToken(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processValidateResetToken(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordRequest | undefined, httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processResetPassword(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processResetPassword(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserRequest | undefined, httpContext?: HttpContext): Observable<UserModel> {
        let url_ = this.baseUrl + "/api/user/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processCreate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processCreate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateUserRequest | undefined, httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processUpdate(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    deleteCurrentUser(httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/delete-current-user";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processDeleteCurrentUser(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeleteCurrentUser(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processDeleteCurrentUser(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteByUserId(body: UserId | undefined, httpContext?: HttpContext): Observable<GenericResult> {
        let url_ = this.baseUrl + "/api/user/delete-by-user-id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processDeleteByUserId(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDeleteByUserId(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenericResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenericResult>;
        }));
    }

    protected processDeleteByUserId(response: HttpResponseBase): Observable<GenericResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenericResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    promote(userId: number, httpContext?: HttpContext): Observable<UserModel> {
        let url_ = this.baseUrl + "/api/user/promote/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processPromote(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processPromote(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel>;
        }));
    }

    protected processPromote(response: HttpResponseBase): Observable<UserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    demote(userId: number, httpContext?: HttpContext): Observable<UserModel> {
        let url_ = this.baseUrl + "/api/user/demote/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        })).pipe(_observableMergeMap((response_: any) => {
            return this.transformResult(url_, response_, (r) => this.processDemote(r as any));
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.transformResult(url_, response_, (r) => this.processDemote(r as any));
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel>;
        }));
    }

    protected processDemote(response: HttpResponseBase): Observable<UserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AuthenticateByDeviceRequest implements IAuthenticateByDeviceRequest {
    deviceId!: string;
    secret!: string;

    constructor(data?: IAuthenticateByDeviceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"] !== undefined ? _data["deviceId"] : <any>null;
            this.secret = _data["secret"] !== undefined ? _data["secret"] : <any>null;
        }
    }

    static fromJS(data: any): AuthenticateByDeviceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateByDeviceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId !== undefined ? this.deviceId : <any>null;
        data["secret"] = this.secret !== undefined ? this.secret : <any>null;
        return data;
    }

    clone(): AuthenticateByDeviceRequest {
        const json = this.toJSON();
        let result = new AuthenticateByDeviceRequest();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateByDeviceRequest {
    deviceId: string;
    secret: string;
}

export class AuthenticateRequest implements IAuthenticateRequest {
    email!: string;
    password!: string;

    constructor(data?: IAuthenticateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): AuthenticateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }

    clone(): AuthenticateRequest {
        const json = this.toJSON();
        let result = new AuthenticateRequest();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateRequest {
    email: string;
    password: string;
}

export class AuthenticateResponse implements IAuthenticateResponse {
    userId?: UserId | null;
    name?: string | null;
    email?: string | null;
    role?: Role;
    isVerified?: boolean;
    requestedAccess?: boolean;
    token?: string | null;
    refreshToken?: string | null;

    constructor(data?: IAuthenticateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] ? UserId.fromJS(_data["userId"]) : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.role = _data["role"] !== undefined ? _data["role"] : <any>null;
            this.isVerified = _data["isVerified"] !== undefined ? _data["isVerified"] : <any>null;
            this.requestedAccess = _data["requestedAccess"] !== undefined ? _data["requestedAccess"] : <any>null;
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
            this.refreshToken = _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
        }
    }

    static fromJS(data: any): AuthenticateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId ? this.userId.toJSON() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["role"] = this.role !== undefined ? this.role : <any>null;
        data["isVerified"] = this.isVerified !== undefined ? this.isVerified : <any>null;
        data["requestedAccess"] = this.requestedAccess !== undefined ? this.requestedAccess : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        data["refreshToken"] = this.refreshToken !== undefined ? this.refreshToken : <any>null;
        return data;
    }

    clone(): AuthenticateResponse {
        const json = this.toJSON();
        let result = new AuthenticateResponse();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResponse {
    userId?: UserId | null;
    name?: string | null;
    email?: string | null;
    role?: Role;
    isVerified?: boolean;
    requestedAccess?: boolean;
    token?: string | null;
    refreshToken?: string | null;
}

export class CoordinatesPositionModel implements ICoordinatesPositionModel {
    latitude?: number;
    latitudeText?: string | null;
    longitude?: number;
    longitudeText?: string | null;
    locationHref?: string | null;
    accuracy?: number;
    altitudeAccuracy?: number | null;
    altitude?: number | null;
    speed?: number | null;
    heading?: number | null;
    state?: string | null;
    city?: string | null;
    country?: string | null;

    constructor(data?: ICoordinatesPositionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.latitude = _data["latitude"] !== undefined ? _data["latitude"] : <any>null;
            this.latitudeText = _data["latitudeText"] !== undefined ? _data["latitudeText"] : <any>null;
            this.longitude = _data["longitude"] !== undefined ? _data["longitude"] : <any>null;
            this.longitudeText = _data["longitudeText"] !== undefined ? _data["longitudeText"] : <any>null;
            this.locationHref = _data["locationHref"] !== undefined ? _data["locationHref"] : <any>null;
            this.accuracy = _data["accuracy"] !== undefined ? _data["accuracy"] : <any>null;
            this.altitudeAccuracy = _data["altitudeAccuracy"] !== undefined ? _data["altitudeAccuracy"] : <any>null;
            this.altitude = _data["altitude"] !== undefined ? _data["altitude"] : <any>null;
            this.speed = _data["speed"] !== undefined ? _data["speed"] : <any>null;
            this.heading = _data["heading"] !== undefined ? _data["heading"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.city = _data["city"] !== undefined ? _data["city"] : <any>null;
            this.country = _data["country"] !== undefined ? _data["country"] : <any>null;
        }
    }

    static fromJS(data: any): CoordinatesPositionModel {
        data = typeof data === 'object' ? data : {};
        let result = new CoordinatesPositionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["latitudeText"] = this.latitudeText !== undefined ? this.latitudeText : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["longitudeText"] = this.longitudeText !== undefined ? this.longitudeText : <any>null;
        data["locationHref"] = this.locationHref !== undefined ? this.locationHref : <any>null;
        data["accuracy"] = this.accuracy !== undefined ? this.accuracy : <any>null;
        data["altitudeAccuracy"] = this.altitudeAccuracy !== undefined ? this.altitudeAccuracy : <any>null;
        data["altitude"] = this.altitude !== undefined ? this.altitude : <any>null;
        data["speed"] = this.speed !== undefined ? this.speed : <any>null;
        data["heading"] = this.heading !== undefined ? this.heading : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["country"] = this.country !== undefined ? this.country : <any>null;
        return data;
    }

    clone(): CoordinatesPositionModel {
        const json = this.toJSON();
        let result = new CoordinatesPositionModel();
        result.init(json);
        return result;
    }
}

export interface ICoordinatesPositionModel {
    latitude?: number;
    latitudeText?: string | null;
    longitude?: number;
    longitudeText?: string | null;
    locationHref?: string | null;
    accuracy?: number;
    altitudeAccuracy?: number | null;
    altitude?: number | null;
    speed?: number | null;
    heading?: number | null;
    state?: string | null;
    city?: string | null;
    country?: string | null;
}

export class CountryModel implements ICountryModel {
    createdDateTime!: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    countryId?: number;
    name?: string | null;
    abbreviation?: string | null;

    constructor(data?: ICountryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>null;
            this.modifiedDateTime = _data["modifiedDateTime"] ? new Date(_data["modifiedDateTime"].toString()) : <any>null;
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>null;
            this.countryId = _data["countryId"] !== undefined ? _data["countryId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.abbreviation = _data["abbreviation"] !== undefined ? _data["abbreviation"] : <any>null;
        }
    }

    static fromJS(data: any): CountryModel {
        data = typeof data === 'object' ? data : {};
        let result = new CountryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>null;
        data["modifiedDateTime"] = this.modifiedDateTime ? this.modifiedDateTime.toISOString() : <any>null;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>null;
        data["countryId"] = this.countryId !== undefined ? this.countryId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["abbreviation"] = this.abbreviation !== undefined ? this.abbreviation : <any>null;
        return data;
    }

    clone(): CountryModel {
        const json = this.toJSON();
        let result = new CountryModel();
        result.init(json);
        return result;
    }
}

export interface ICountryModel {
    createdDateTime: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    countryId?: number;
    name?: string | null;
    abbreviation?: string | null;
}

export class CreateGameRequest implements ICreateGameRequest {
    title?: string | null;
    description?: string | null;

    constructor(data?: ICreateGameRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): CreateGameRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGameRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }

    clone(): CreateGameRequest {
        const json = this.toJSON();
        let result = new CreateGameRequest();
        result.init(json);
        return result;
    }
}

export interface ICreateGameRequest {
    title?: string | null;
    description?: string | null;
}

export class CreateLicensePlateRequest implements ICreateLicensePlateRequest {
    title?: string | null;
    author?: string | null;
    description?: string | null;
    storage?: string | null;
    ingredients?: string | null;
    directions?: string | null;
    cookTime?: TimeSpan | null;
    prepTime?: TimeSpan | null;
    totalTime?: TimeSpan | null;
    servings?: number | null;
    yield?: string | null;
    nutrition?: string | null;

    constructor(data?: ICreateLicensePlateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.author = _data["author"] !== undefined ? _data["author"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.storage = _data["storage"] !== undefined ? _data["storage"] : <any>null;
            this.ingredients = _data["ingredients"] !== undefined ? _data["ingredients"] : <any>null;
            this.directions = _data["directions"] !== undefined ? _data["directions"] : <any>null;
            this.cookTime = _data["cookTime"] ? TimeSpan.fromJS(_data["cookTime"]) : <any>null;
            this.prepTime = _data["prepTime"] ? TimeSpan.fromJS(_data["prepTime"]) : <any>null;
            this.totalTime = _data["totalTime"] ? TimeSpan.fromJS(_data["totalTime"]) : <any>null;
            this.servings = _data["servings"] !== undefined ? _data["servings"] : <any>null;
            this.yield = _data["yield"] !== undefined ? _data["yield"] : <any>null;
            this.nutrition = _data["nutrition"] !== undefined ? _data["nutrition"] : <any>null;
        }
    }

    static fromJS(data: any): CreateLicensePlateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLicensePlateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["author"] = this.author !== undefined ? this.author : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["storage"] = this.storage !== undefined ? this.storage : <any>null;
        data["ingredients"] = this.ingredients !== undefined ? this.ingredients : <any>null;
        data["directions"] = this.directions !== undefined ? this.directions : <any>null;
        data["cookTime"] = this.cookTime ? this.cookTime.toJSON() : <any>null;
        data["prepTime"] = this.prepTime ? this.prepTime.toJSON() : <any>null;
        data["totalTime"] = this.totalTime ? this.totalTime.toJSON() : <any>null;
        data["servings"] = this.servings !== undefined ? this.servings : <any>null;
        data["yield"] = this.yield !== undefined ? this.yield : <any>null;
        data["nutrition"] = this.nutrition !== undefined ? this.nutrition : <any>null;
        return data;
    }

    clone(): CreateLicensePlateRequest {
        const json = this.toJSON();
        let result = new CreateLicensePlateRequest();
        result.init(json);
        return result;
    }
}

export interface ICreateLicensePlateRequest {
    title?: string | null;
    author?: string | null;
    description?: string | null;
    storage?: string | null;
    ingredients?: string | null;
    directions?: string | null;
    cookTime?: TimeSpan | null;
    prepTime?: TimeSpan | null;
    totalTime?: TimeSpan | null;
    servings?: number | null;
    yield?: string | null;
    nutrition?: string | null;
}

export class CreateUserRequest implements ICreateUserRequest {
    firstName!: string;
    lastName!: string;
    role!: string;
    email!: string;
    password!: string;
    confirmPassword!: string;

    constructor(data?: ICreateUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.role = _data["role"] !== undefined ? _data["role"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.confirmPassword = _data["confirmPassword"] !== undefined ? _data["confirmPassword"] : <any>null;
        }
    }

    static fromJS(data: any): CreateUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["role"] = this.role !== undefined ? this.role : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["confirmPassword"] = this.confirmPassword !== undefined ? this.confirmPassword : <any>null;
        return data;
    }

    clone(): CreateUserRequest {
        const json = this.toJSON();
        let result = new CreateUserRequest();
        result.init(json);
        return result;
    }
}

export interface ICreateUserRequest {
    firstName: string;
    lastName: string;
    role: string;
    email: string;
    password: string;
    confirmPassword: string;
}

export class DocumentModel implements IDocumentModel {
    createdDateTime!: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    createdBy?: UserModel | null;
    modifiedBy?: UserModel | null;
    deletedBy?: UserModel | null;
    documentId?: number;
    name?: string | null;
    fileName?: string | null;
    description?: string | null;
    contentType?: string | null;
    byteSize?: number;
    bytes?: string | null;
    documentKey?: string;

    constructor(data?: IDocumentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>null;
            this.modifiedDateTime = _data["modifiedDateTime"] ? new Date(_data["modifiedDateTime"].toString()) : <any>null;
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] ? UserModel.fromJS(_data["createdBy"]) : <any>null;
            this.modifiedBy = _data["modifiedBy"] ? UserModel.fromJS(_data["modifiedBy"]) : <any>null;
            this.deletedBy = _data["deletedBy"] ? UserModel.fromJS(_data["deletedBy"]) : <any>null;
            this.documentId = _data["documentId"] !== undefined ? _data["documentId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.fileName = _data["fileName"] !== undefined ? _data["fileName"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.contentType = _data["contentType"] !== undefined ? _data["contentType"] : <any>null;
            this.byteSize = _data["byteSize"] !== undefined ? _data["byteSize"] : <any>null;
            this.bytes = _data["bytes"] !== undefined ? _data["bytes"] : <any>null;
            this.documentKey = _data["documentKey"] !== undefined ? _data["documentKey"] : <any>null;
        }
    }

    static fromJS(data: any): DocumentModel {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>null;
        data["modifiedDateTime"] = this.modifiedDateTime ? this.modifiedDateTime.toISOString() : <any>null;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>null;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>null;
        data["modifiedBy"] = this.modifiedBy ? this.modifiedBy.toJSON() : <any>null;
        data["deletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>null;
        data["documentId"] = this.documentId !== undefined ? this.documentId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["fileName"] = this.fileName !== undefined ? this.fileName : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["contentType"] = this.contentType !== undefined ? this.contentType : <any>null;
        data["byteSize"] = this.byteSize !== undefined ? this.byteSize : <any>null;
        data["bytes"] = this.bytes !== undefined ? this.bytes : <any>null;
        data["documentKey"] = this.documentKey !== undefined ? this.documentKey : <any>null;
        return data;
    }

    clone(): DocumentModel {
        const json = this.toJSON();
        let result = new DocumentModel();
        result.init(json);
        return result;
    }
}

export interface IDocumentModel {
    createdDateTime: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    createdBy?: UserModel | null;
    modifiedBy?: UserModel | null;
    deletedBy?: UserModel | null;
    documentId?: number;
    name?: string | null;
    fileName?: string | null;
    description?: string | null;
    contentType?: string | null;
    byteSize?: number;
    bytes?: string | null;
    documentKey?: string;
}

export class EmailGameDataRequest implements IEmailGameDataRequest {
    email!: string;
    jsonData!: string;

    constructor(data?: IEmailGameDataRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.jsonData = _data["jsonData"] !== undefined ? _data["jsonData"] : <any>null;
        }
    }

    static fromJS(data: any): EmailGameDataRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EmailGameDataRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["jsonData"] = this.jsonData !== undefined ? this.jsonData : <any>null;
        return data;
    }

    clone(): EmailGameDataRequest {
        const json = this.toJSON();
        let result = new EmailGameDataRequest();
        result.init(json);
        return result;
    }
}

export interface IEmailGameDataRequest {
    email: string;
    jsonData: string;
}

export class FeedbackModel implements IFeedbackModel {
    feedbackId?: number | null;
    userId?: string | null;
    rating?: number | null;
    comments?: string | null;
    canContact?: boolean;

    constructor(data?: IFeedbackModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feedbackId = _data["feedbackId"] !== undefined ? _data["feedbackId"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.rating = _data["rating"] !== undefined ? _data["rating"] : <any>null;
            this.comments = _data["comments"] !== undefined ? _data["comments"] : <any>null;
            this.canContact = _data["canContact"] !== undefined ? _data["canContact"] : <any>null;
        }
    }

    static fromJS(data: any): FeedbackModel {
        data = typeof data === 'object' ? data : {};
        let result = new FeedbackModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feedbackId"] = this.feedbackId !== undefined ? this.feedbackId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["rating"] = this.rating !== undefined ? this.rating : <any>null;
        data["comments"] = this.comments !== undefined ? this.comments : <any>null;
        data["canContact"] = this.canContact !== undefined ? this.canContact : <any>null;
        return data;
    }

    clone(): FeedbackModel {
        const json = this.toJSON();
        let result = new FeedbackModel();
        result.init(json);
        return result;
    }
}

export interface IFeedbackModel {
    feedbackId?: number | null;
    userId?: string | null;
    rating?: number | null;
    comments?: string | null;
    canContact?: boolean;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email!: string;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        return data;
    }

    clone(): ForgotPasswordRequest {
        const json = this.toJSON();
        let result = new ForgotPasswordRequest();
        result.init(json);
        return result;
    }
}

export interface IForgotPasswordRequest {
    email: string;
}

export class GameId implements IGameId {
    value?: number;

    constructor(data?: IGameId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): GameId {
        data = typeof data === 'object' ? data : {};
        let result = new GameId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }

    clone(): GameId {
        const json = this.toJSON();
        let result = new GameId();
        result.init(json);
        return result;
    }
}

export interface IGameId {
    value?: number;
}

export class GameLicensePlateModel implements IGameLicensePlateModel {
    createdDateTime!: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    gameLicensePlateId?: number;
    licensePlate?: LicensePlateModel | null;
    vehicles?: StateVehicleModel[] | null;
    notes?: string | null;

    constructor(data?: IGameLicensePlateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>null;
            this.modifiedDateTime = _data["modifiedDateTime"] ? new Date(_data["modifiedDateTime"].toString()) : <any>null;
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>null;
            this.gameLicensePlateId = _data["gameLicensePlateId"] !== undefined ? _data["gameLicensePlateId"] : <any>null;
            this.licensePlate = _data["licensePlate"] ? LicensePlateModel.fromJS(_data["licensePlate"]) : <any>null;
            if (Array.isArray(_data["vehicles"])) {
                this.vehicles = [] as any;
                for (let item of _data["vehicles"])
                    this.vehicles!.push(StateVehicleModel.fromJS(item));
            }
            else {
                this.vehicles = <any>null;
            }
            this.notes = _data["notes"] !== undefined ? _data["notes"] : <any>null;
        }
    }

    static fromJS(data: any): GameLicensePlateModel {
        data = typeof data === 'object' ? data : {};
        let result = new GameLicensePlateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>null;
        data["modifiedDateTime"] = this.modifiedDateTime ? this.modifiedDateTime.toISOString() : <any>null;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>null;
        data["gameLicensePlateId"] = this.gameLicensePlateId !== undefined ? this.gameLicensePlateId : <any>null;
        data["licensePlate"] = this.licensePlate ? this.licensePlate.toJSON() : <any>null;
        if (Array.isArray(this.vehicles)) {
            data["vehicles"] = [];
            for (let item of this.vehicles)
                data["vehicles"].push(item.toJSON());
        }
        data["notes"] = this.notes !== undefined ? this.notes : <any>null;
        return data;
    }

    clone(): GameLicensePlateModel {
        const json = this.toJSON();
        let result = new GameLicensePlateModel();
        result.init(json);
        return result;
    }
}

export interface IGameLicensePlateModel {
    createdDateTime: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    gameLicensePlateId?: number;
    licensePlate?: LicensePlateModel | null;
    vehicles?: StateVehicleModel[] | null;
    notes?: string | null;
}

export class GameModel implements IGameModel {
    createdDateTime!: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    gameId?: number;
    gameNumber?: number;
    title?: string | null;
    description?: string | null;
    licensePlates?: GameLicensePlateModel[] | null;
    startedDateTime?: Date | null;
    finishedDateTime?: Date | null;
    totalDays?: number;
    totalMiles?: number;
    platesFound?: number;
    currentUSA?: number;
    currentCA?: number;
    hasDCSelected?: boolean;

    constructor(data?: IGameModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>null;
            this.modifiedDateTime = _data["modifiedDateTime"] ? new Date(_data["modifiedDateTime"].toString()) : <any>null;
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>null;
            this.gameId = _data["gameId"] !== undefined ? _data["gameId"] : <any>null;
            this.gameNumber = _data["gameNumber"] !== undefined ? _data["gameNumber"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            if (Array.isArray(_data["licensePlates"])) {
                this.licensePlates = [] as any;
                for (let item of _data["licensePlates"])
                    this.licensePlates!.push(GameLicensePlateModel.fromJS(item));
            }
            else {
                this.licensePlates = <any>null;
            }
            this.startedDateTime = _data["startedDateTime"] ? new Date(_data["startedDateTime"].toString()) : <any>null;
            this.finishedDateTime = _data["finishedDateTime"] ? new Date(_data["finishedDateTime"].toString()) : <any>null;
            this.totalDays = _data["totalDays"] !== undefined ? _data["totalDays"] : <any>null;
            this.totalMiles = _data["totalMiles"] !== undefined ? _data["totalMiles"] : <any>null;
            this.platesFound = _data["platesFound"] !== undefined ? _data["platesFound"] : <any>null;
            this.currentUSA = _data["currentUSA"] !== undefined ? _data["currentUSA"] : <any>null;
            this.currentCA = _data["currentCA"] !== undefined ? _data["currentCA"] : <any>null;
            this.hasDCSelected = _data["hasDCSelected"] !== undefined ? _data["hasDCSelected"] : <any>null;
        }
    }

    static fromJS(data: any): GameModel {
        data = typeof data === 'object' ? data : {};
        let result = new GameModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>null;
        data["modifiedDateTime"] = this.modifiedDateTime ? this.modifiedDateTime.toISOString() : <any>null;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>null;
        data["gameId"] = this.gameId !== undefined ? this.gameId : <any>null;
        data["gameNumber"] = this.gameNumber !== undefined ? this.gameNumber : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        if (Array.isArray(this.licensePlates)) {
            data["licensePlates"] = [];
            for (let item of this.licensePlates)
                data["licensePlates"].push(item.toJSON());
        }
        data["startedDateTime"] = this.startedDateTime ? this.startedDateTime.toISOString() : <any>null;
        data["finishedDateTime"] = this.finishedDateTime ? this.finishedDateTime.toISOString() : <any>null;
        data["totalDays"] = this.totalDays !== undefined ? this.totalDays : <any>null;
        data["totalMiles"] = this.totalMiles !== undefined ? this.totalMiles : <any>null;
        data["platesFound"] = this.platesFound !== undefined ? this.platesFound : <any>null;
        data["currentUSA"] = this.currentUSA !== undefined ? this.currentUSA : <any>null;
        data["currentCA"] = this.currentCA !== undefined ? this.currentCA : <any>null;
        data["hasDCSelected"] = this.hasDCSelected !== undefined ? this.hasDCSelected : <any>null;
        return data;
    }

    clone(): GameModel {
        const json = this.toJSON();
        let result = new GameModel();
        result.init(json);
        return result;
    }
}

export interface IGameModel {
    createdDateTime: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    gameId?: number;
    gameNumber?: number;
    title?: string | null;
    description?: string | null;
    licensePlates?: GameLicensePlateModel[] | null;
    startedDateTime?: Date | null;
    finishedDateTime?: Date | null;
    totalDays?: number;
    totalMiles?: number;
    platesFound?: number;
    currentUSA?: number;
    currentCA?: number;
    hasDCSelected?: boolean;
}

export class GenericResult implements IGenericResult {
    success?: boolean;
    message?: string | null;

    constructor(data?: IGenericResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
        }
    }

    static fromJS(data: any): GenericResult {
        data = typeof data === 'object' ? data : {};
        let result = new GenericResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data;
    }

    clone(): GenericResult {
        const json = this.toJSON();
        let result = new GenericResult();
        result.init(json);
        return result;
    }
}

export interface IGenericResult {
    success?: boolean;
    message?: string | null;
}

export class GroupModel implements IGroupModel {
    createdDateTime!: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    groupId?: string | null;
    groupNumber?: number;
    title?: string | null;
    description?: string | null;
    games?: GameModel[] | null;
    memberUserIds?: string[] | null;
    ownerUserId?: string | null;

    constructor(data?: IGroupModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>null;
            this.modifiedDateTime = _data["modifiedDateTime"] ? new Date(_data["modifiedDateTime"].toString()) : <any>null;
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>null;
            this.groupId = _data["groupId"] !== undefined ? _data["groupId"] : <any>null;
            this.groupNumber = _data["groupNumber"] !== undefined ? _data["groupNumber"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            if (Array.isArray(_data["games"])) {
                this.games = [] as any;
                for (let item of _data["games"])
                    this.games!.push(GameModel.fromJS(item));
            }
            else {
                this.games = <any>null;
            }
            if (Array.isArray(_data["memberUserIds"])) {
                this.memberUserIds = [] as any;
                for (let item of _data["memberUserIds"])
                    this.memberUserIds!.push(item);
            }
            else {
                this.memberUserIds = <any>null;
            }
            this.ownerUserId = _data["ownerUserId"] !== undefined ? _data["ownerUserId"] : <any>null;
        }
    }

    static fromJS(data: any): GroupModel {
        data = typeof data === 'object' ? data : {};
        let result = new GroupModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>null;
        data["modifiedDateTime"] = this.modifiedDateTime ? this.modifiedDateTime.toISOString() : <any>null;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>null;
        data["groupId"] = this.groupId !== undefined ? this.groupId : <any>null;
        data["groupNumber"] = this.groupNumber !== undefined ? this.groupNumber : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        if (Array.isArray(this.games)) {
            data["games"] = [];
            for (let item of this.games)
                data["games"].push(item.toJSON());
        }
        if (Array.isArray(this.memberUserIds)) {
            data["memberUserIds"] = [];
            for (let item of this.memberUserIds)
                data["memberUserIds"].push(item);
        }
        data["ownerUserId"] = this.ownerUserId !== undefined ? this.ownerUserId : <any>null;
        return data;
    }

    clone(): GroupModel {
        const json = this.toJSON();
        let result = new GroupModel();
        result.init(json);
        return result;
    }
}

export interface IGroupModel {
    createdDateTime: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    groupId?: string | null;
    groupNumber?: number;
    title?: string | null;
    description?: string | null;
    games?: GameModel[] | null;
    memberUserIds?: string[] | null;
    ownerUserId?: string | null;
}

export class LicenseGameRequest implements ILicenseGameRequest {
    gameId?: GameId | null;
    licensePlateId?: LicensePlateId | null;

    constructor(data?: ILicenseGameRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gameId = _data["gameId"] ? GameId.fromJS(_data["gameId"]) : <any>null;
            this.licensePlateId = _data["licensePlateId"] ? LicensePlateId.fromJS(_data["licensePlateId"]) : <any>null;
        }
    }

    static fromJS(data: any): LicenseGameRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LicenseGameRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameId"] = this.gameId ? this.gameId.toJSON() : <any>null;
        data["licensePlateId"] = this.licensePlateId ? this.licensePlateId.toJSON() : <any>null;
        return data;
    }

    clone(): LicenseGameRequest {
        const json = this.toJSON();
        let result = new LicenseGameRequest();
        result.init(json);
        return result;
    }
}

export interface ILicenseGameRequest {
    gameId?: GameId | null;
    licensePlateId?: LicensePlateId | null;
}

export class LicensePlateId implements ILicensePlateId {
    value?: number;

    constructor(data?: ILicensePlateId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): LicensePlateId {
        data = typeof data === 'object' ? data : {};
        let result = new LicensePlateId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }

    clone(): LicensePlateId {
        const json = this.toJSON();
        let result = new LicensePlateId();
        result.init(json);
        return result;
    }
}

export interface ILicensePlateId {
    value?: number;
}

export class LicensePlateModel implements ILicensePlateModel {
    createdDateTime!: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    licensePlateId?: number;
    title?: string | null;
    description?: string | null;
    image?: string | null;
    state?: StateModel | null;
    isRarePlate?: boolean;
    miles?: number;

    constructor(data?: ILicensePlateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>null;
            this.modifiedDateTime = _data["modifiedDateTime"] ? new Date(_data["modifiedDateTime"].toString()) : <any>null;
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>null;
            this.licensePlateId = _data["licensePlateId"] !== undefined ? _data["licensePlateId"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.image = _data["image"] !== undefined ? _data["image"] : <any>null;
            this.state = _data["state"] ? StateModel.fromJS(_data["state"]) : <any>null;
            this.isRarePlate = _data["isRarePlate"] !== undefined ? _data["isRarePlate"] : <any>null;
            this.miles = _data["miles"] !== undefined ? _data["miles"] : <any>null;
        }
    }

    static fromJS(data: any): LicensePlateModel {
        data = typeof data === 'object' ? data : {};
        let result = new LicensePlateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>null;
        data["modifiedDateTime"] = this.modifiedDateTime ? this.modifiedDateTime.toISOString() : <any>null;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>null;
        data["licensePlateId"] = this.licensePlateId !== undefined ? this.licensePlateId : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["image"] = this.image !== undefined ? this.image : <any>null;
        data["state"] = this.state ? this.state.toJSON() : <any>null;
        data["isRarePlate"] = this.isRarePlate !== undefined ? this.isRarePlate : <any>null;
        data["miles"] = this.miles !== undefined ? this.miles : <any>null;
        return data;
    }

    clone(): LicensePlateModel {
        const json = this.toJSON();
        let result = new LicensePlateModel();
        result.init(json);
        return result;
    }
}

export interface ILicensePlateModel {
    createdDateTime: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    licensePlateId?: number;
    title?: string | null;
    description?: string | null;
    image?: string | null;
    state?: StateModel | null;
    isRarePlate?: boolean;
    miles?: number;
}

export enum LocationType {
    Unknown = "Unknown",
    Traveling = "Traveling",
    Hotel = "Hotel",
    Airport = "Airport",
    OtherParkingLot = "OtherParkingLot",
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
    token?: string | null;

    constructor(data?: IRefreshTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
        }
    }

    static fromJS(data: any): RefreshTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token !== undefined ? this.token : <any>null;
        return data;
    }

    clone(): RefreshTokenRequest {
        const json = this.toJSON();
        let result = new RefreshTokenRequest();
        result.init(json);
        return result;
    }
}

export interface IRefreshTokenRequest {
    token?: string | null;
}

export class RegisterRequest implements IRegisterRequest {
    name!: string;
    email!: string;
    password!: string;
    confirmPassword!: string;
    deviceId?: string | null;
    deviceToken?: string | null;
    timeZone?: string | null;
    utcOffset?: number;
    model?: string | null;
    manufacturer?: string | null;
    operatingSystem?: string | null;
    operatingSystemVersion?: string | null;
    platform?: string | null;
    webViewVersion?: string | null;
    isVirtual?: boolean;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.confirmPassword = _data["confirmPassword"] !== undefined ? _data["confirmPassword"] : <any>null;
            this.deviceId = _data["deviceId"] !== undefined ? _data["deviceId"] : <any>null;
            this.deviceToken = _data["deviceToken"] !== undefined ? _data["deviceToken"] : <any>null;
            this.timeZone = _data["timeZone"] !== undefined ? _data["timeZone"] : <any>null;
            this.utcOffset = _data["utcOffset"] !== undefined ? _data["utcOffset"] : <any>null;
            this.model = _data["model"] !== undefined ? _data["model"] : <any>null;
            this.manufacturer = _data["manufacturer"] !== undefined ? _data["manufacturer"] : <any>null;
            this.operatingSystem = _data["operatingSystem"] !== undefined ? _data["operatingSystem"] : <any>null;
            this.operatingSystemVersion = _data["operatingSystemVersion"] !== undefined ? _data["operatingSystemVersion"] : <any>null;
            this.platform = _data["platform"] !== undefined ? _data["platform"] : <any>null;
            this.webViewVersion = _data["webViewVersion"] !== undefined ? _data["webViewVersion"] : <any>null;
            this.isVirtual = _data["isVirtual"] !== undefined ? _data["isVirtual"] : <any>null;
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["confirmPassword"] = this.confirmPassword !== undefined ? this.confirmPassword : <any>null;
        data["deviceId"] = this.deviceId !== undefined ? this.deviceId : <any>null;
        data["deviceToken"] = this.deviceToken !== undefined ? this.deviceToken : <any>null;
        data["timeZone"] = this.timeZone !== undefined ? this.timeZone : <any>null;
        data["utcOffset"] = this.utcOffset !== undefined ? this.utcOffset : <any>null;
        data["model"] = this.model !== undefined ? this.model : <any>null;
        data["manufacturer"] = this.manufacturer !== undefined ? this.manufacturer : <any>null;
        data["operatingSystem"] = this.operatingSystem !== undefined ? this.operatingSystem : <any>null;
        data["operatingSystemVersion"] = this.operatingSystemVersion !== undefined ? this.operatingSystemVersion : <any>null;
        data["platform"] = this.platform !== undefined ? this.platform : <any>null;
        data["webViewVersion"] = this.webViewVersion !== undefined ? this.webViewVersion : <any>null;
        data["isVirtual"] = this.isVirtual !== undefined ? this.isVirtual : <any>null;
        return data;
    }

    clone(): RegisterRequest {
        const json = this.toJSON();
        let result = new RegisterRequest();
        result.init(json);
        return result;
    }
}

export interface IRegisterRequest {
    name: string;
    email: string;
    password: string;
    confirmPassword: string;
    deviceId?: string | null;
    deviceToken?: string | null;
    timeZone?: string | null;
    utcOffset?: number;
    model?: string | null;
    manufacturer?: string | null;
    operatingSystem?: string | null;
    operatingSystemVersion?: string | null;
    platform?: string | null;
    webViewVersion?: string | null;
    isVirtual?: boolean;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    token!: string;
    password!: string;
    confirmPassword!: string;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.confirmPassword = _data["confirmPassword"] !== undefined ? _data["confirmPassword"] : <any>null;
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token !== undefined ? this.token : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["confirmPassword"] = this.confirmPassword !== undefined ? this.confirmPassword : <any>null;
        return data;
    }

    clone(): ResetPasswordRequest {
        const json = this.toJSON();
        let result = new ResetPasswordRequest();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordRequest {
    token: string;
    password: string;
    confirmPassword: string;
}

export class RevokeTokenRequest implements IRevokeTokenRequest {
    token?: string | null;

    constructor(data?: IRevokeTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
        }
    }

    static fromJS(data: any): RevokeTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RevokeTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token !== undefined ? this.token : <any>null;
        return data;
    }

    clone(): RevokeTokenRequest {
        const json = this.toJSON();
        let result = new RevokeTokenRequest();
        result.init(json);
        return result;
    }
}

export interface IRevokeTokenRequest {
    token?: string | null;
}

export enum Role {
    Unknown = "Unknown",
    User = "User",
    Editor = "Editor",
    Admin = "Admin",
}

export class SecretResponse implements ISecretResponse {
    secret?: string | null;

    constructor(data?: ISecretResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.secret = _data["secret"] !== undefined ? _data["secret"] : <any>null;
        }
    }

    static fromJS(data: any): SecretResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SecretResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["secret"] = this.secret !== undefined ? this.secret : <any>null;
        return data;
    }

    clone(): SecretResponse {
        const json = this.toJSON();
        let result = new SecretResponse();
        result.init(json);
        return result;
    }
}

export interface ISecretResponse {
    secret?: string | null;
}

export class StateFactModel implements IStateFactModel {
    createdDateTime!: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    stateId?: number;
    stateName?: string | null;
    facts?: string[] | null;
    state?: StateModel | null;

    constructor(data?: IStateFactModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>null;
            this.modifiedDateTime = _data["modifiedDateTime"] ? new Date(_data["modifiedDateTime"].toString()) : <any>null;
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>null;
            this.stateId = _data["stateId"] !== undefined ? _data["stateId"] : <any>null;
            this.stateName = _data["stateName"] !== undefined ? _data["stateName"] : <any>null;
            if (Array.isArray(_data["facts"])) {
                this.facts = [] as any;
                for (let item of _data["facts"])
                    this.facts!.push(item);
            }
            else {
                this.facts = <any>null;
            }
            this.state = _data["state"] ? StateModel.fromJS(_data["state"]) : <any>null;
        }
    }

    static fromJS(data: any): StateFactModel {
        data = typeof data === 'object' ? data : {};
        let result = new StateFactModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>null;
        data["modifiedDateTime"] = this.modifiedDateTime ? this.modifiedDateTime.toISOString() : <any>null;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>null;
        data["stateId"] = this.stateId !== undefined ? this.stateId : <any>null;
        data["stateName"] = this.stateName !== undefined ? this.stateName : <any>null;
        if (Array.isArray(this.facts)) {
            data["facts"] = [];
            for (let item of this.facts)
                data["facts"].push(item);
        }
        data["state"] = this.state ? this.state.toJSON() : <any>null;
        return data;
    }

    clone(): StateFactModel {
        const json = this.toJSON();
        let result = new StateFactModel();
        result.init(json);
        return result;
    }
}

export interface IStateFactModel {
    createdDateTime: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    stateId?: number;
    stateName?: string | null;
    facts?: string[] | null;
    state?: StateModel | null;
}

export class StateFactResult implements IStateFactResult {
    fact?: string | null;

    constructor(data?: IStateFactResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fact = _data["fact"] !== undefined ? _data["fact"] : <any>null;
        }
    }

    static fromJS(data: any): StateFactResult {
        data = typeof data === 'object' ? data : {};
        let result = new StateFactResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fact"] = this.fact !== undefined ? this.fact : <any>null;
        return data;
    }

    clone(): StateFactResult {
        const json = this.toJSON();
        let result = new StateFactResult();
        result.init(json);
        return result;
    }
}

export interface IStateFactResult {
    fact?: string | null;
}

export class StateModel implements IStateModel {
    createdDateTime!: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    stateId?: number;
    name?: string | null;
    abbreviation?: string | null;
    countryId?: number;
    country?: CountryModel | null;
    slogan?: string | null;
    bird?: string | null;
    flower?: string | null;
    color?: string | null;

    constructor(data?: IStateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>null;
            this.modifiedDateTime = _data["modifiedDateTime"] ? new Date(_data["modifiedDateTime"].toString()) : <any>null;
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>null;
            this.stateId = _data["stateId"] !== undefined ? _data["stateId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.abbreviation = _data["abbreviation"] !== undefined ? _data["abbreviation"] : <any>null;
            this.countryId = _data["countryId"] !== undefined ? _data["countryId"] : <any>null;
            this.country = _data["country"] ? CountryModel.fromJS(_data["country"]) : <any>null;
            this.slogan = _data["slogan"] !== undefined ? _data["slogan"] : <any>null;
            this.bird = _data["bird"] !== undefined ? _data["bird"] : <any>null;
            this.flower = _data["flower"] !== undefined ? _data["flower"] : <any>null;
            this.color = _data["color"] !== undefined ? _data["color"] : <any>null;
        }
    }

    static fromJS(data: any): StateModel {
        data = typeof data === 'object' ? data : {};
        let result = new StateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>null;
        data["modifiedDateTime"] = this.modifiedDateTime ? this.modifiedDateTime.toISOString() : <any>null;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>null;
        data["stateId"] = this.stateId !== undefined ? this.stateId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["abbreviation"] = this.abbreviation !== undefined ? this.abbreviation : <any>null;
        data["countryId"] = this.countryId !== undefined ? this.countryId : <any>null;
        data["country"] = this.country ? this.country.toJSON() : <any>null;
        data["slogan"] = this.slogan !== undefined ? this.slogan : <any>null;
        data["bird"] = this.bird !== undefined ? this.bird : <any>null;
        data["flower"] = this.flower !== undefined ? this.flower : <any>null;
        data["color"] = this.color !== undefined ? this.color : <any>null;
        return data;
    }

    clone(): StateModel {
        const json = this.toJSON();
        let result = new StateModel();
        result.init(json);
        return result;
    }
}

export interface IStateModel {
    createdDateTime: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    stateId?: number;
    name?: string | null;
    abbreviation?: string | null;
    countryId?: number;
    country?: CountryModel | null;
    slogan?: string | null;
    bird?: string | null;
    flower?: string | null;
    color?: string | null;
}

export class StateVehicleModel implements IStateVehicleModel {
    createdDateTime!: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    stateVehicleModelId?: number;
    location?: CoordinatesPositionModel | null;
    locationType?: LocationType | null;
    vehicleType?: VehicleType;
    isCommercial?: boolean;
    isSameState?: boolean;
    notes?: string | null;
    isoDate?: string | null;
    foundDateTime?: Date;

    constructor(data?: IStateVehicleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>null;
            this.modifiedDateTime = _data["modifiedDateTime"] ? new Date(_data["modifiedDateTime"].toString()) : <any>null;
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>null;
            this.stateVehicleModelId = _data["stateVehicleModelId"] !== undefined ? _data["stateVehicleModelId"] : <any>null;
            this.location = _data["location"] ? CoordinatesPositionModel.fromJS(_data["location"]) : <any>null;
            this.locationType = _data["locationType"] !== undefined ? _data["locationType"] : <any>null;
            this.vehicleType = _data["vehicleType"] !== undefined ? _data["vehicleType"] : <any>null;
            this.isCommercial = _data["isCommercial"] !== undefined ? _data["isCommercial"] : <any>null;
            this.isSameState = _data["isSameState"] !== undefined ? _data["isSameState"] : <any>null;
            this.notes = _data["notes"] !== undefined ? _data["notes"] : <any>null;
            this.isoDate = _data["isoDate"] !== undefined ? _data["isoDate"] : <any>null;
            this.foundDateTime = _data["foundDateTime"] ? new Date(_data["foundDateTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): StateVehicleModel {
        data = typeof data === 'object' ? data : {};
        let result = new StateVehicleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>null;
        data["modifiedDateTime"] = this.modifiedDateTime ? this.modifiedDateTime.toISOString() : <any>null;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>null;
        data["stateVehicleModelId"] = this.stateVehicleModelId !== undefined ? this.stateVehicleModelId : <any>null;
        data["location"] = this.location ? this.location.toJSON() : <any>null;
        data["locationType"] = this.locationType !== undefined ? this.locationType : <any>null;
        data["vehicleType"] = this.vehicleType !== undefined ? this.vehicleType : <any>null;
        data["isCommercial"] = this.isCommercial !== undefined ? this.isCommercial : <any>null;
        data["isSameState"] = this.isSameState !== undefined ? this.isSameState : <any>null;
        data["notes"] = this.notes !== undefined ? this.notes : <any>null;
        data["isoDate"] = this.isoDate !== undefined ? this.isoDate : <any>null;
        data["foundDateTime"] = this.foundDateTime ? this.foundDateTime.toISOString() : <any>null;
        return data;
    }

    clone(): StateVehicleModel {
        const json = this.toJSON();
        let result = new StateVehicleModel();
        result.init(json);
        return result;
    }
}

export interface IStateVehicleModel {
    createdDateTime: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    stateVehicleModelId?: number;
    location?: CoordinatesPositionModel | null;
    locationType?: LocationType | null;
    vehicleType?: VehicleType;
    isCommercial?: boolean;
    isSameState?: boolean;
    notes?: string | null;
    isoDate?: string | null;
    foundDateTime?: Date;
}

export class TimeSpan implements ITimeSpan {
    ticks?: number;
    readonly days?: number;
    readonly hours?: number;
    readonly milliseconds?: number;
    readonly microseconds?: number;
    readonly nanoseconds?: number;
    readonly minutes?: number;
    readonly seconds?: number;
    readonly totalDays?: number;
    readonly totalHours?: number;
    readonly totalMilliseconds?: number;
    readonly totalMicroseconds?: number;
    readonly totalNanoseconds?: number;
    readonly totalMinutes?: number;
    readonly totalSeconds?: number;

    constructor(data?: ITimeSpan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticks = _data["ticks"] !== undefined ? _data["ticks"] : <any>null;
            (<any>this).days = _data["days"] !== undefined ? _data["days"] : <any>null;
            (<any>this).hours = _data["hours"] !== undefined ? _data["hours"] : <any>null;
            (<any>this).milliseconds = _data["milliseconds"] !== undefined ? _data["milliseconds"] : <any>null;
            (<any>this).microseconds = _data["microseconds"] !== undefined ? _data["microseconds"] : <any>null;
            (<any>this).nanoseconds = _data["nanoseconds"] !== undefined ? _data["nanoseconds"] : <any>null;
            (<any>this).minutes = _data["minutes"] !== undefined ? _data["minutes"] : <any>null;
            (<any>this).seconds = _data["seconds"] !== undefined ? _data["seconds"] : <any>null;
            (<any>this).totalDays = _data["totalDays"] !== undefined ? _data["totalDays"] : <any>null;
            (<any>this).totalHours = _data["totalHours"] !== undefined ? _data["totalHours"] : <any>null;
            (<any>this).totalMilliseconds = _data["totalMilliseconds"] !== undefined ? _data["totalMilliseconds"] : <any>null;
            (<any>this).totalMicroseconds = _data["totalMicroseconds"] !== undefined ? _data["totalMicroseconds"] : <any>null;
            (<any>this).totalNanoseconds = _data["totalNanoseconds"] !== undefined ? _data["totalNanoseconds"] : <any>null;
            (<any>this).totalMinutes = _data["totalMinutes"] !== undefined ? _data["totalMinutes"] : <any>null;
            (<any>this).totalSeconds = _data["totalSeconds"] !== undefined ? _data["totalSeconds"] : <any>null;
        }
    }

    static fromJS(data: any): TimeSpan {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSpan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticks"] = this.ticks !== undefined ? this.ticks : <any>null;
        data["days"] = this.days !== undefined ? this.days : <any>null;
        data["hours"] = this.hours !== undefined ? this.hours : <any>null;
        data["milliseconds"] = this.milliseconds !== undefined ? this.milliseconds : <any>null;
        data["microseconds"] = this.microseconds !== undefined ? this.microseconds : <any>null;
        data["nanoseconds"] = this.nanoseconds !== undefined ? this.nanoseconds : <any>null;
        data["minutes"] = this.minutes !== undefined ? this.minutes : <any>null;
        data["seconds"] = this.seconds !== undefined ? this.seconds : <any>null;
        data["totalDays"] = this.totalDays !== undefined ? this.totalDays : <any>null;
        data["totalHours"] = this.totalHours !== undefined ? this.totalHours : <any>null;
        data["totalMilliseconds"] = this.totalMilliseconds !== undefined ? this.totalMilliseconds : <any>null;
        data["totalMicroseconds"] = this.totalMicroseconds !== undefined ? this.totalMicroseconds : <any>null;
        data["totalNanoseconds"] = this.totalNanoseconds !== undefined ? this.totalNanoseconds : <any>null;
        data["totalMinutes"] = this.totalMinutes !== undefined ? this.totalMinutes : <any>null;
        data["totalSeconds"] = this.totalSeconds !== undefined ? this.totalSeconds : <any>null;
        return data;
    }

    clone(): TimeSpan {
        const json = this.toJSON();
        let result = new TimeSpan();
        result.init(json);
        return result;
    }
}

export interface ITimeSpan {
    ticks?: number;
    days?: number;
    hours?: number;
    milliseconds?: number;
    microseconds?: number;
    nanoseconds?: number;
    minutes?: number;
    seconds?: number;
    totalDays?: number;
    totalHours?: number;
    totalMilliseconds?: number;
    totalMicroseconds?: number;
    totalNanoseconds?: number;
    totalMinutes?: number;
    totalSeconds?: number;
}

export class UpdateGameRequest implements IUpdateGameRequest {
    gameId?: GameId | null;
    title?: string | null;
    description?: string | null;
    licensePlatesToDelete?: LicensePlateModel[] | null;

    constructor(data?: IUpdateGameRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gameId = _data["gameId"] ? GameId.fromJS(_data["gameId"]) : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            if (Array.isArray(_data["licensePlatesToDelete"])) {
                this.licensePlatesToDelete = [] as any;
                for (let item of _data["licensePlatesToDelete"])
                    this.licensePlatesToDelete!.push(LicensePlateModel.fromJS(item));
            }
            else {
                this.licensePlatesToDelete = <any>null;
            }
        }
    }

    static fromJS(data: any): UpdateGameRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGameRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gameId"] = this.gameId ? this.gameId.toJSON() : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        if (Array.isArray(this.licensePlatesToDelete)) {
            data["licensePlatesToDelete"] = [];
            for (let item of this.licensePlatesToDelete)
                data["licensePlatesToDelete"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateGameRequest {
        const json = this.toJSON();
        let result = new UpdateGameRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdateGameRequest {
    gameId?: GameId | null;
    title?: string | null;
    description?: string | null;
    licensePlatesToDelete?: LicensePlateModel[] | null;
}

export class UpdateLicensePlateRequest implements IUpdateLicensePlateRequest {
    id?: LicensePlateId | null;
    title?: string | null;
    author?: string | null;
    description?: string | null;
    storage?: string | null;
    ingredients?: string | null;
    directions?: string | null;
    cookTime?: TimeSpan | null;
    prepTime?: TimeSpan | null;
    totalTime?: TimeSpan | null;
    servings?: number | null;
    yield?: string | null;
    nutrition?: string | null;
    documentsToDelete?: DocumentModel[] | null;

    constructor(data?: IUpdateLicensePlateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] ? LicensePlateId.fromJS(_data["id"]) : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.author = _data["author"] !== undefined ? _data["author"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.storage = _data["storage"] !== undefined ? _data["storage"] : <any>null;
            this.ingredients = _data["ingredients"] !== undefined ? _data["ingredients"] : <any>null;
            this.directions = _data["directions"] !== undefined ? _data["directions"] : <any>null;
            this.cookTime = _data["cookTime"] ? TimeSpan.fromJS(_data["cookTime"]) : <any>null;
            this.prepTime = _data["prepTime"] ? TimeSpan.fromJS(_data["prepTime"]) : <any>null;
            this.totalTime = _data["totalTime"] ? TimeSpan.fromJS(_data["totalTime"]) : <any>null;
            this.servings = _data["servings"] !== undefined ? _data["servings"] : <any>null;
            this.yield = _data["yield"] !== undefined ? _data["yield"] : <any>null;
            this.nutrition = _data["nutrition"] !== undefined ? _data["nutrition"] : <any>null;
            if (Array.isArray(_data["documentsToDelete"])) {
                this.documentsToDelete = [] as any;
                for (let item of _data["documentsToDelete"])
                    this.documentsToDelete!.push(DocumentModel.fromJS(item));
            }
            else {
                this.documentsToDelete = <any>null;
            }
        }
    }

    static fromJS(data: any): UpdateLicensePlateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLicensePlateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id ? this.id.toJSON() : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["author"] = this.author !== undefined ? this.author : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["storage"] = this.storage !== undefined ? this.storage : <any>null;
        data["ingredients"] = this.ingredients !== undefined ? this.ingredients : <any>null;
        data["directions"] = this.directions !== undefined ? this.directions : <any>null;
        data["cookTime"] = this.cookTime ? this.cookTime.toJSON() : <any>null;
        data["prepTime"] = this.prepTime ? this.prepTime.toJSON() : <any>null;
        data["totalTime"] = this.totalTime ? this.totalTime.toJSON() : <any>null;
        data["servings"] = this.servings !== undefined ? this.servings : <any>null;
        data["yield"] = this.yield !== undefined ? this.yield : <any>null;
        data["nutrition"] = this.nutrition !== undefined ? this.nutrition : <any>null;
        if (Array.isArray(this.documentsToDelete)) {
            data["documentsToDelete"] = [];
            for (let item of this.documentsToDelete)
                data["documentsToDelete"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateLicensePlateRequest {
        const json = this.toJSON();
        let result = new UpdateLicensePlateRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdateLicensePlateRequest {
    id?: LicensePlateId | null;
    title?: string | null;
    author?: string | null;
    description?: string | null;
    storage?: string | null;
    ingredients?: string | null;
    directions?: string | null;
    cookTime?: TimeSpan | null;
    prepTime?: TimeSpan | null;
    totalTime?: TimeSpan | null;
    servings?: number | null;
    yield?: string | null;
    nutrition?: string | null;
    documentsToDelete?: DocumentModel[] | null;
}

export class UpdateUserRequest implements IUpdateUserRequest {
    name?: string | null;

    constructor(data?: IUpdateUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }

    clone(): UpdateUserRequest {
        const json = this.toJSON();
        let result = new UpdateUserRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserRequest {
    name?: string | null;
}

export class UploadResult implements IUploadResult {
    uploaded?: boolean;
    fileName?: string | null;
    errorCode?: number | null;
    message?: string | null;

    constructor(data?: IUploadResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uploaded = _data["uploaded"] !== undefined ? _data["uploaded"] : <any>null;
            this.fileName = _data["fileName"] !== undefined ? _data["fileName"] : <any>null;
            this.errorCode = _data["errorCode"] !== undefined ? _data["errorCode"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
        }
    }

    static fromJS(data: any): UploadResult {
        data = typeof data === 'object' ? data : {};
        let result = new UploadResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uploaded"] = this.uploaded !== undefined ? this.uploaded : <any>null;
        data["fileName"] = this.fileName !== undefined ? this.fileName : <any>null;
        data["errorCode"] = this.errorCode !== undefined ? this.errorCode : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data;
    }

    clone(): UploadResult {
        const json = this.toJSON();
        let result = new UploadResult();
        result.init(json);
        return result;
    }
}

export interface IUploadResult {
    uploaded?: boolean;
    fileName?: string | null;
    errorCode?: number | null;
    message?: string | null;
}

export class UserId implements IUserId {
    value?: number;

    constructor(data?: IUserId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): UserId {
        data = typeof data === 'object' ? data : {};
        let result = new UserId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }

    clone(): UserId {
        const json = this.toJSON();
        let result = new UserId();
        result.init(json);
        return result;
    }
}

export interface IUserId {
    value?: number;
}

export class UserModel implements IUserModel {
    createdDateTime!: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    userId?: UserId | null;
    userGUID?: string | null;
    lastIPAddress?: string | null;
    lastLogin?: Date | null;
    lastLogout?: Date | null;
    timeZone?: string | null;
    utcOffset?: number | null;
    email?: string | null;
    name?: string | null;
    groups?: GroupModel[] | null;
    role?: Role;
    requestedAccess?: boolean;
    requestedAccessExpires?: Date | null;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDateTime = _data["createdDateTime"] ? new Date(_data["createdDateTime"].toString()) : <any>null;
            this.modifiedDateTime = _data["modifiedDateTime"] ? new Date(_data["modifiedDateTime"].toString()) : <any>null;
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>null;
            this.userId = _data["userId"] ? UserId.fromJS(_data["userId"]) : <any>null;
            this.userGUID = _data["userGUID"] !== undefined ? _data["userGUID"] : <any>null;
            this.lastIPAddress = _data["lastIPAddress"] !== undefined ? _data["lastIPAddress"] : <any>null;
            this.lastLogin = _data["lastLogin"] ? new Date(_data["lastLogin"].toString()) : <any>null;
            this.lastLogout = _data["lastLogout"] ? new Date(_data["lastLogout"].toString()) : <any>null;
            this.timeZone = _data["timeZone"] !== undefined ? _data["timeZone"] : <any>null;
            this.utcOffset = _data["utcOffset"] !== undefined ? _data["utcOffset"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(GroupModel.fromJS(item));
            }
            else {
                this.groups = <any>null;
            }
            this.role = _data["role"] !== undefined ? _data["role"] : <any>null;
            this.requestedAccess = _data["requestedAccess"] !== undefined ? _data["requestedAccess"] : <any>null;
            this.requestedAccessExpires = _data["requestedAccessExpires"] ? new Date(_data["requestedAccessExpires"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDateTime"] = this.createdDateTime ? this.createdDateTime.toISOString() : <any>null;
        data["modifiedDateTime"] = this.modifiedDateTime ? this.modifiedDateTime.toISOString() : <any>null;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>null;
        data["userId"] = this.userId ? this.userId.toJSON() : <any>null;
        data["userGUID"] = this.userGUID !== undefined ? this.userGUID : <any>null;
        data["lastIPAddress"] = this.lastIPAddress !== undefined ? this.lastIPAddress : <any>null;
        data["lastLogin"] = this.lastLogin ? this.lastLogin.toISOString() : <any>null;
        data["lastLogout"] = this.lastLogout ? this.lastLogout.toISOString() : <any>null;
        data["timeZone"] = this.timeZone !== undefined ? this.timeZone : <any>null;
        data["utcOffset"] = this.utcOffset !== undefined ? this.utcOffset : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        data["role"] = this.role !== undefined ? this.role : <any>null;
        data["requestedAccess"] = this.requestedAccess !== undefined ? this.requestedAccess : <any>null;
        data["requestedAccessExpires"] = this.requestedAccessExpires ? this.requestedAccessExpires.toISOString() : <any>null;
        return data;
    }

    clone(): UserModel {
        const json = this.toJSON();
        let result = new UserModel();
        result.init(json);
        return result;
    }
}

export interface IUserModel {
    createdDateTime: Date;
    modifiedDateTime?: Date | null;
    deletedDateTime?: Date | null;
    userId?: UserId | null;
    userGUID?: string | null;
    lastIPAddress?: string | null;
    lastLogin?: Date | null;
    lastLogout?: Date | null;
    timeZone?: string | null;
    utcOffset?: number | null;
    email?: string | null;
    name?: string | null;
    groups?: GroupModel[] | null;
    role?: Role;
    requestedAccess?: boolean;
    requestedAccessExpires?: Date | null;
}

export class ValidateResetTokenRequest implements IValidateResetTokenRequest {
    token!: string;

    constructor(data?: IValidateResetTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
        }
    }

    static fromJS(data: any): ValidateResetTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateResetTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token !== undefined ? this.token : <any>null;
        return data;
    }

    clone(): ValidateResetTokenRequest {
        const json = this.toJSON();
        let result = new ValidateResetTokenRequest();
        result.init(json);
        return result;
    }
}

export interface IValidateResetTokenRequest {
    token: string;
}

export enum VehicleType {
    Unknown = "Unknown",
    Car = "Car",
    Truck = "Truck",
    Motorcycle = "Motorcycle",
    RV = "RV",
    Bus = "Bus",
    Other = "Other",
}

export class VerifyEmailRequest implements IVerifyEmailRequest {
    token!: string;

    constructor(data?: IVerifyEmailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
        }
    }

    static fromJS(data: any): VerifyEmailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyEmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token !== undefined ? this.token : <any>null;
        return data;
    }

    clone(): VerifyEmailRequest {
        const json = this.toJSON();
        let result = new VerifyEmailRequest();
        result.init(json);
        return result;
    }
}

export interface IVerifyEmailRequest {
    token: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

/**
Copyright 2023 Scott Lewis, All rights reserved.
**/
/**
 * Copyright 2023 Scott Lewis, All rights reserved.
 */